options {
  STATIC = false;
}

PARSER_BEGIN(Parser)

package crono;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

// PROTIP: we can't statically import NIL because javacc gives it special
// meaning in Parser
import crono.AbstractSyntax.*;
import crono.Cons;
import crono.CronoOptions;
import crono.Nil;

public class Parser {
}

PARSER_END(Parser)

SKIP:
{
    " "
  | "\t"
  | "\n"
  | "\r"
  | <"%" (~["\n","\r"])* ("\n"|"\r")>
}

TOKEN:
{
    < NIL : ["N","n"] ["I","i"] ["L","l"] >
}

TOKEN:
{
    < LPAR : "(" >
  | < RPAR : ")" >
  | < QUOTE : "'" >
  | < INTEGER : ("+" | "-")? (["0"-"9"])+ >
  | < FLOAT : (["+", "-"])? (["0"-"9"])+ "." (["0"-"9"])+ >
  | < CHAR : "'" ([" "-"~"] | ("\\" ~["\n", "\r"])) "'" >
  | < STRING : "\"" ("\\" ~["\n"] | ~["\"", "\n"])* "\"" >
  | < SYMBOL : ["!"-"'", "*"-"/", ":"-"~"] (["!"-"'", "*"-"~"])* >
}

TOKEN:
{
  < ERROR : ~[] >
}

Atom atom():
{ Token n; }
{
    <NIL>         { return Nil.NIL; }
  | n = <INTEGER> { return new CronoNumber(Long.valueOf(n.image)); }
  | n = <FLOAT>   { return new CronoFloat(Double.valueOf(n.image)); }
  | n = <CHAR>    {
      if(n.image.length() == 4) { /*< '\n' */
        return CronoCharacter.escape(n.image.charAt(2));
      }
      return new CronoCharacter(n.image.charAt(1));
    }
  | n = <SYMBOL>  { return Symbol.valueOf(n.image); }
}

Cons string():
{ Token n; }
{
  n = <STRING> {
    List<CronoType> list = new LinkedList<CronoType>();
    int strlen = n.image.length() - 1;
    boolean escaped = false;
    char _c;
    for(int i = 1; i < strlen; ++i) {
      _c = n.image.charAt(i);
      if(escaped) {
        list.add(CronoCharacter.escape(_c));
	escaped = false;
      }else {
        if(_c == '\\') {
	  escaped = true;
	}else {
	  list.add(new CronoCharacter(_c));
	}
      }
    }
    list.add(Nil.NIL);
    return new Cons(list);
  }
}

Cons list():
{
  Token n;
  Atom a;
  Cons c;
  List<CronoType> l = new ArrayList<CronoType>();
  boolean quoted = false;
}
{
    c = string() {
      return c;
    }
  | <LPAR>
  (
      c = list() {
        if (CronoOptions.PARSER_DPRINT) {
          CronoOptions.dprint("Saw LIST: %s\n",c);
        }
        l.add(c);
      }
    | a = atom() {
        if (CronoOptions.PARSER_DPRINT) {
          CronoOptions.dprint("Saw ATOM: %s [ %s ]\n", a,
            a.getClass().getName());
        }
        l.add(a);
      }
  )*
  <RPAR>
  {
    if (l.size() == 0) {
      return Nil.NIL;
    } else {
      l.add(Nil.NIL);
      return new Cons(l);
    }
  }
}

CronoType prog(Environment env):
{
  List<CronoType> l;
  LambdaFunction lf;
  Cons c;
  Atom a;
  CronoType lastResult = null;
}
{
  (
      c = list() {
        if (CronoOptions.PARSER_DPRINT) {
          CronoOptions.dprint("Saw LIST: %s\n",c);
        }
        l = new ArrayList<CronoType>();
        l.add(c);
        lf = new LambdaFunction(l, env);
        lastResult = Interpreter.run(lf, env);
        env = lf.environment;
      }
    | a = atom() {
        if (CronoOptions.PARSER_DPRINT) {
          CronoOptions.dprint("Saw ATOM: %s [ %s ]\n", a,
            a.getClass().getName());
        }
        l = new ArrayList<CronoType>();
        l.add(a);
        lf = new LambdaFunction(l, env);
        lastResult = Interpreter.run(lf, env);
        env = lf.environment;
      }
    | <RPAR> { throw new ParseException("Unmatched parenthesis"); }
  )* {
    return lastResult;
  }
}
